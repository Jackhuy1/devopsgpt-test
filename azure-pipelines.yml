trigger:
- main

variables:
  imageName: 'nginx-website'
  acrName: 'terratamldacr' # Replace with your actual ACR name
  acrServiceConnection: 'acr-connection' # Replace with your actual ACR service connection name
  azureSubscription: 'azure-service-connection' # Replace with your Azure subscription name
  resourceGroup: 'terraform-aks' # Replace with your resource group name
  aksCluster: 'terra-aks' # Replace with your AKS cluster name
  imageTag: '$(Build.BuildId)'
  deploymentManifest: '$(System.DefaultWorkingDirectory)/deployment.yaml'
  serviceManifest: '$(System.DefaultWorkingDirectory)/service.yaml'
  deploymentName: 'nginx' # Will be set dynamically

stages:
- stage: Build
  displayName: Build and Push Docker Image
  jobs:
  - job: Build
    displayName: Build and Push
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self

    - task: Docker@2
      displayName: Build and push image to ACR
      inputs:
        command: buildAndPush
        repository: $(acrName).azurecr.io/$(imageName)
        dockerfile: Dockerfile
        containerRegistry: $(acrServiceConnection)
        tags: |
          $(imageTag)
          latest

    - task: Bash@3
      displayName: Install yq for YAML editing
      inputs:
        targetType: 'inline'
        script: |
          set -e
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.43.1/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

    - task: Bash@3
      displayName: Update deployment manifest with image tag using yq
      inputs:
        targetType: 'inline'
        script: |
          set -e
          # Find the container name in the deployment manifest
          container_name=$(yq '.spec.template.spec.containers[0].name' $(deploymentManifest))
          # Update the image field for the first container
          yq -i '.spec.template.spec.containers[0].image = strenv(acrName) + ".azurecr.io/" + strenv(imageName) + ":" + strenv(imageTag)' $(deploymentManifest)
          # Output the updated image for verification
          echo "Updated image:"
          yq '.spec.template.spec.containers[0].image' $(deploymentManifest)

    - task: Bash@3
      displayName: Extract deployment name from manifest
      name: ExtractDeploymentName
      inputs:
        targetType: 'inline'
        script: |
          set -e
          DEPLOYMENT_NAME=$(yq '.metadata.name' $(deploymentManifest))
          echo "##vso[task.setvariable variable=deploymentName;isOutput=true]$DEPLOYMENT_NAME"
      env:
        deploymentManifest: $(deploymentManifest)

- stage: Deploy
  displayName: Deploy to AKS
  dependsOn: Build
  jobs:
  - job: Deploy
    displayName: Deploy to AKS
    pool:
      vmImage: 'ubuntu-latest'
    variables:
      deploymentName: $[ dependencies.Build.outputs['Build.ExtractDeploymentName.deploymentName'] ]
    steps:
    - checkout: self

    - task: Kubernetes@1
      displayName: Get AKS credentials
      inputs:
        connectionType: 'Azure Resource Manager'
        azureSubscriptionEndpoint: 'azure-service-connection'
        azureResourceGroup: $(resourceGroup)
        kubernetesCluster: $(aksCluster)
        namespace: default
        command: 'getClusterCredentials'

    - task: AzureCLI@2
      displayName: Create Kubernetes secret for ACR authentication
      inputs:
        azureSubscriptionEndpoint: 'azure-service-connection'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -e
          ACR_USERNAME=$(az acr credential show -n $(acrName) --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show -n $(acrName) --query passwords[0].value -o tsv)
          kubectl create secret docker-registry acr-auth \
            --docker-server=$(acrName).azurecr.io \
            --docker-username=$ACR_USERNAME \
            --docker-password=$ACR_PASSWORD \
            --namespace=default --dry-run=client -o yaml | kubectl apply -f -

    - task: Bash@3
      displayName: Ensure imagePullSecrets in deployment manifest using yq
      inputs:
        targetType: 'inline'
        script: |
          set -e
          # Check if imagePullSecrets exists and contains acr-auth
          if yq '.spec.template.spec.imagePullSecrets' $(deploymentManifest) | grep -q 'acr-auth'; then
            echo "imagePullSecrets already contains acr-auth"
          else
            # Add or update imagePullSecrets
            if yq '.spec.template.spec | has("imagePullSecrets")' $(deploymentManifest) | grep -q 'true'; then
              # imagePullSecrets exists, append acr-auth if not present
              yq -i '.spec.template.spec.imagePullSecrets += [{"name": "acr-auth"}] | .spec.template.spec.imagePullSecrets |= unique_by(.name)' $(deploymentManifest)
            else
              # imagePullSecrets does not exist, create it
              yq -i '.spec.template.spec.imagePullSecrets = [{"name": "acr-auth"}]' $(deploymentManifest)
            fi
            echo "Added acr-auth to imagePullSecrets"
          fi

    - task: Kubernetes@1
      displayName: Deploy manifests to AKS
      inputs:
        connectionType: 'Azure Resource Manager'
        azureSubscriptionEndpoint: 'azure-service-connection'
        azureResourceGroup: $(resourceGroup)
        kubernetesCluster: $(aksCluster)
        namespace: default
        command: apply
        useConfigurationFile: true
        configuration: |
          $(deploymentManifest)
          $(serviceManifest)

    - task: Kubernetes@1
      displayName: Check deployment rollout status
      inputs:
        connectionType: 'Azure Resource Manager'
        azureSubscriptionEndpoint: 'azure-service-connection'
        azureResourceGroup: $(resourceGroup)
        kubernetesCluster: $(aksCluster)
        namespace: default
        command: 'kubectl'
        arguments: 'rollout status deployment/$(deploymentName)'
